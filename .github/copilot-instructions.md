# AI Coding Agent Guidelines for 360_Viewer
- **Architecture**: Two packages share a repo. `backend/` is an Express + Mongoose API that also serves the built React app. `pano-viewer/` is a CRA-based React UI that consumes the API and hosts the 360° viewer (`react-photo-sphere-viewer`).
- **Local setup**: Copy `backend/.env.example` to `.env` and fill MongoDB + AWS S3 credentials. Use `start-dev.bat` (Windows) to boot both servers (`backend:npm run dev`, `pano-viewer:npm start`). API defaults to `http://localhost:5000`, frontend to `http://localhost:3000`.
- **Data model**: Projects (`backend/models/Project.js`) own many panophotos (`backend/models/Panophoto.js`). Each panophoto stores S3 asset metadata plus `xPosition`/`yPosition` in the unit square and a `linkedPhotos` array of objects `{ target, azimuth, azimuthOffset }` for bidirectional navigation and marker metadata.
- **Linking contract**: When creating or removing links, update both photos. The API already enforces this (`PATCH /api/panophotos/:id/link|unlink` in `backend/routes/panophotos.js`) and now computes azimuths based on the stored positions. Preserve the add-to-set / pull symmetry and keep offsets untouched when adjusting azimuths.
- **File storage**: Panophoto uploads use in-memory `multer`, generate deterministic S3 keys via `slugify`, and persist both to S3 (`PutObjectCommand`) and MongoDB. Deleting a photo must remove its S3 object and unlink it from all neighbors.
- **Start scene**: Projects record a `startPanophoto` reference. The editor calls `PATCH /api/projects/:id/start` to set it; uploads auto-fill it with the oldest photo when empty, and deletions fall back to the next-oldest scene.
- **Viewer routing**: `Panoviewer` prefers a `state.panophotoId` or `?id=` query to pull metadata from the API, then falls back to `state.src`, `?src=`, or `testPanorama.jpg` if no id is present. Always include the id when linking between scenes so markers load correctly.
- **Viewer markers**: `Panoviewer` fetches scene metadata from `GET /api/panophotos/:id`, converts each link into a `MarkersPlugin` marker, and navigates by pushing `/viewer?id=...`. Ensure link updates keep azimuth values accurate so markers face the right direction; offsets stay editable for fine-tuning.
- **Viewer UI**: The viewer overlays a toolbar in the top-left with a “Back to Editor” button that routes to `/projects/editor`; keep it visible over the sphere when adjusting layouts.
- **Project editor workflow**: `Pages/ProjectEditor.js` is the control center for positioning and linking. Positions are stored as normalized floats (0–1); UI multiplies by 100 for SVG overlay rendering. Keep this contract when adding spatial features (e.g., azimuth math should consume the same normalized coordinates).
- **Fetching conventions**: The frontend uses vanilla `fetch` with `credentials: 'include'` and expects JSON error bodies. Mirror the existing pattern (try `response.json()` with fallback to `.text()`) when adding new requests so status messaging stays consistent.
- **Component styling**: Shared styles live in `pano-viewer/src/CSS/styles.css` plus component-specific files. Components in `src/Components/` are functional and rely on prop-driven state; follow the same pattern and reuse existing CSS utility classes where possible.
- **Deployment**: Production flow builds the React app (`pano-viewer/npm run build`) and runs the backend (`backend/npm start`), which serves the build output and APIs from a single Express instance. Ensure backend routes stay under `/api` to avoid clashing with the catch-all React handler.

Feel free to iterate on these notes—flag unclear sections so we can refine them.